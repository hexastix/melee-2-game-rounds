<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>2-game rounds for Melee</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    >
  </head>
  <body>
    <nav class="navbar sticky-top bg-body-secondary">
      <div class="container">
        <span class="navbar-brand">2-game rounds for Melee</span>
      </div>
    </nav>
    <div class="container my-4">
      <div class="row d-flex align-items-end">
        <div class="col">
          <label for="players-file-input" class="form-label">Player data (JSON file)</label>
          <input type="file" accept="application/json" id="players-file-input" class="form-control" />
        </div>
        <div class="col">
          <label for="matches-file-input" class="form-label">Tournament matches (JSON file)</label>
          <input type="file" accept="application/json" id="matches-file-input" class="form-control" />
        </div>
        <div class="col">
          <button type="button" id="submit-button" class="form-control">Submit</button>
        </div>
      </div>
    </div>
    <div class="container my-4">
      <h2>Standings</h2>
      <div id="standings-pane" class="overflow-x-auto">
        <p>No standings</p>
      </div>
    </div>
    <div class="container my-4">
      <h2>Matches</h2>
      <div class="bg-body-secondary">
        <div id="rounds-tabs" class="nav nav-pills justify-content-center">
        </div>
      </div>
      <div id="rounds-panes" class="tab-content">
        <p>No matches</p>
      </div>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
      integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
      crossorigin="anonymous"
    ></script>
    <script>
      function handleFile(fileInput, validateItems, assignItems) {
        fileInput.parentNode.classList.remove("was-validated");

        const files = fileInput.files;
        switch (files.length) {
          case 0:
            return;
          case 1: {
            const playersFile = fileInput.files[0];
            if (playersFile.type === "application/json") {
              const reader = new FileReader();
              reader.onload = (event) => {
                let items = [];
                try {
                  items = JSON.parse(event.target.result);
                } catch {
                  fileInput.setCustomValidity("Invalid JSON");
                  fileInput.parentNode.classList.add("was-validated");
                  return;
                }

                const validity = validateItems(items);
                if (validity === "") {
                  assignItems(items);
                }
                fileInput.setCustomValidity(validity);
                fileInput.parentNode.classList.add("was-validated");
              };
              reader.onerror = (event) => {
                fileInput.setCustomValidity("Failed to read the file");
                fileInput.parentNode.classList.add("was-validated");
              };
              reader.readAsText(playersFile);
              return;
            } else {
              fileInput.setCustomValidity("Incorrect file type");
            }
            break;
          }
          default:
            fileInput.setCustomValidity("Too many files");
        }

        fileInput.parentNode.classList.add("was-validated");
      }

      function validatePlayers(players) {
        if (!Array.isArray(players)) {
          return "Invalid JSON contents (expected array of players)";
        }
        for (property of ["Username", "PlayerName", "TeamId", "Status"]) {
          if (!players.every((player) => Object.hasOwn(player, property))) {
            return `Invalid JSON contents (missing "${property}" property)`;
          }
        }
        return "";
      }

      var players = [];
      const assignPlayers = (items) => { players = items; };

      const playersFileInput = document.getElementById("players-file-input");
      playersFileInput.addEventListener(
        "change",
        (event) => { handleFile(playersFileInput, validatePlayers, assignPlayers) },
      );

      function validateMatches(matches) {
        if (!Array.isArray(matches)) {
          return "Invalid JSON contents (expected array of matches)";
        }
        for (property of [
          "Player1Username",
          "Player2Username",
          "Player1GameAndByeWins",
          "Player2GameAndByeWins",
          "HasResults",
          "GameDraws",
        ]) {
          if (!matches.every((match) => Object.hasOwn(match, property))) {
            return `Invalid JSON contents (missing "${property}" property)`;
          }
        }
        const invalidMatches = matches.filter(
          (match) => match.Player1GameAndByeWins + match.Player2GameAndByeWins > 2
        ).length;
        if (invalidMatches !== 0) {
          return (
            `${invalidMatches} match${invalidMatches === 1 ? '' : 'es' } with invalid`
            + ' result'
          );
        }
        return "";
      }

      var matches = [];
      const assignMatches = (items) => { matches = items; }

      const matchesFileInput = document.getElementById("matches-file-input");
      matchesFileInput.addEventListener(
        "change",
        (event) => { handleFile(matchesFileInput, validateMatches, assignMatches) },
      );

      handleFile(playersFileInput, validatePlayers, assignPlayers);
      handleFile(matchesFileInput, validateMatches, assignMatches);

      const submitButton = document.getElementById("submit-button");
      submitButton.onclick = (event) => {
        playersFileInput.required = true;
        playersFileInput.parentNode.classList.add("was-validated");
        matchesFileInput.required = true;
        matchesFileInput.parentNode.classList.add("was-validated");

        const roundsTabs = document.getElementById("rounds-tabs");
        roundsTabs.replaceChildren();

        const roundsPanes = document.getElementById("rounds-panes");
        roundsPanes.replaceChildren();

        const standingsPane = document.getElementById("standings-pane");
        standingsPane.replaceChildren();

        if (matches.length === 0) {
          const matchesText = document.createElement("p");
          matchesText.appendChild(document.createTextNode("No matches"));
          roundsPanes.replaceChildren(matchesText);

          const standingsText = document.createElement("p");
          standingsText.appendChild(document.createTextNode("No standings"));
          standingsPane.replaceChildren(standingsText);

          submitButton.blur();
          return;
        }

        const roundNumbers = [... new Set(matches.map((match) => match.RoundNumber))];
        const completedRoundNumbers = roundNumbers.filter(
          (number) =>
            matches
              .filter((match) => match.RoundNumber === number)
              .every((match) => match.HasResults)
        );

        roundNumbers.forEach((number, index) => {
          const active = number === roundNumbers[roundNumbers.length - 1]
            && !(
              roundNumbers.length === completedRoundNumbers.length
                && players.length !== 0
            );

          const roundTab = document.createElement("button");
          roundTab.setAttribute("type", "button");
          roundTab.setAttribute("class", `nav-link my-3 ${active ? "active" : ""}`);
          roundTab.setAttribute("data-bs-toggle", "pill");
          roundTab.setAttribute("data-bs-target", `#round-${number}-pane`);
          roundTab.appendChild(document.createTextNode(`Round ${number}`));
          roundsTabs.appendChild(roundTab);

          const roundPane = document.createElement("div");
          roundPane.setAttribute("class", `tab-pane ${active ? "active" : ""}`);
          roundPane.setAttribute("id", `round-${number}-pane`);

          const matchesTable = document.createElement("table");
          matchesTable.setAttribute("class", "table table-striped table-hover");

          const matchesTableHeader = document.createElement("thead");
          const matchesTableHeaderRow = matchesTableHeader.insertRow();
          [["Player 1", 40], ["Result", 20], ["Player 2", 40]].forEach((elem) => {
            const [text, width] = elem;
            const cell = document.createElement("th");
            cell.setAttribute("style", `width: ${width}%`);
            cell.appendChild(document.createTextNode(text))
            matchesTableHeaderRow.appendChild(cell);
          });
          matchesTable.appendChild(matchesTableHeader);

          const matchesTableBody = document.createElement("tbody");
          matches.filter((match) => match.RoundNumber === number).forEach((match) => {
            const row = matchesTableBody.insertRow();
            const player1 = players.filter(
              (player) => player.Username === match.Player1Username
            )[0];
            const player1Name = (
              player1 ? player1.PlayerNameLastFirst : match.Player1Username
            );
            const player2 = players.filter(
              (player) => player.Username === match.Player2Username
            )[0];
            const player2Name = (
              player2 ? player2.PlayerNameLastFirst : match.Player2Username
            );
            const result = match.HasResults
              ? `${match.Player1GameAndByeWins} - ${match.Player2GameAndByeWins}`
              : "Not reported";
            for (text of [
              player1Name ? player1Name : "N/A (bye)",
              result,
              player2Name ? player2Name : "N/A (bye)",
            ]) {
              row.insertCell().appendChild(document.createTextNode(text));
            }
          });
          matchesTable.appendChild(matchesTableBody);

          roundPane.appendChild(matchesTable);
          roundsPanes.appendChild(roundPane);
        });

        let nextRoundPane = null;

        if (roundNumbers.length === completedRoundNumbers.length) {
          const active = players.length !== 0;

          const roundTab = document.createElement("button");
          roundTab.setAttribute("type", "button");
          roundTab.setAttribute("class", `nav-link my-3 ${active ? "active" : ""}`);
          roundTab.setAttribute("data-bs-toggle", "pill");
          roundTab.setAttribute("data-bs-target", "#next-round-pane");
          roundTab.appendChild(document.createTextNode("Next round"));
          roundsTabs.appendChild(roundTab);

          nextRoundPane = document.createElement("div");
          nextRoundPane.setAttribute("class", `tab-pane ${active ? "active" : ""}`);
          nextRoundPane.setAttribute("id", "next-round-pane");
          roundsPanes.appendChild(nextRoundPane);
        }

        if (players.length === 0) {
          const standingsText = document.createElement("p");
          standingsText.appendChild(
            document.createTextNode("No standings (missing player data)")
          );
          standingsPane.replaceChildren(standingsText);

          if (nextRoundPane) {
            const pairingsHeader = document.createElement("h4");
            pairingsHeader.setAttribute("class", "my-2");
            pairingsHeader.appendChild(document.createTextNode("Pairings"));

            const pairingsText = document.createElement("p");
            pairingsText.appendChild(
              document.createTextNode("No pairings (missing player data)")
            );

            nextRoundPane.replaceChildren(pairingsHeader, pairingsText);
          }

          submitButton.blur();
          return;
        }

        const sum = (a, b) => { return a + b; };

        const computeMatches = (username) => {
          return matches.filter(
            (match) =>
              completedRoundNumbers.includes(match.RoundNumber)
                && [match.Player1Username, match.Player2Username].includes(username)
          )
        }

        const computePoints = (username) => {
          return computeMatches(username)
            .map((match) =>
              match.GameDraws === 3
                ? 0
                : username === match.Player1Username
                  ? match.Player1GameAndByeWins === 2 ? 3 : match.Player1GameAndByeWins
                  : match.Player2GameAndByeWins === 2 ? 3 : match.Player2GameAndByeWins
            )
            .reduce(sum, 0);
        };

        const computeGamesWon = (username) => {
          return computeMatches(username)
            .map((match) =>
              username === match.Player1Username
                ? match.Player1GameAndByeWins : match.Player2GameAndByeWins
            )
            .reduce(sum, 0);
        };

        const computeOpponents = (username) => {
          return computeMatches(username)
            .map((match) =>
              username === match.Player1Username
                ? match.Player2Username : match.Player1Username
            )
            .filter((opponent) => opponent);
        };

        const computeStrengthOfSchedule = (username) => {
          const opponents = computeOpponents(username);
          if (opponents.length === 0) {
            return 0.0;
          }
          return (
            opponents
              .map(
                (opponent) => Math.max(
                  1 / 3, computePoints(opponent) / (3 * computeMatches(opponent).length),
                )
              )
              .reduce(sum, 0)
            / opponents.length
          );
        };

        const computeLastWins = (username) => {
          return computeMatches(username)
            .map((match) =>
              match.GameDraws === 3
                ? [0, 0]
                : username === match.Player1Username
                  ? match.Player1GameAndByeWins === (
                      match.Player1GameAndByeWins + match.Player2GameAndByeWins
                    )
                    ? [1, 1]
                    : match.Player1GameAndByeWins === 0 ? [0, 0] : [0, 1]
                  : match.Player2GameAndByeWins === (
                      match.Player1GameAndByeWins + match.Player2GameAndByeWins
                    )
                    ? [1, 1]
                    : match.Player2GameAndByeWins === 0 ? [0, 0] : [0, 1]
            )
            .reduce((a, b) => [a[0] + b[0], a[1] + b[1]], [0, 0])
        };

        const computeRecord = (username) => {
          return computeMatches(username)
            .map((match) =>
              match.GameDraws === 3
                ? [0, 1, 0]
                : username === match.Player1Username
                  ? match.Player1GameAndByeWins === 2
                    ? [1, 0, 0]
                    : match.Player1GameAndByeWins === 1 ? [0, 0, 1] : [0, 1, 0]
                  : match.Player2GameAndByeWins === 2
                    ? [1, 0, 0]
                    : match.Player2GameAndByeWins === 1 ? [0, 0, 1] : [0, 1, 0]
            )
            .reduce((a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]], [0, 0, 0]);
        };

        const standings = players
          .filter((player) => [1, 2, 3, 4, 8, 9, 10].includes(player.Status))
          .map((player) => [
            computePoints(player.Username),
            computeGamesWon(player.Username),
            Math.round(10e5 * computeStrengthOfSchedule(player.Username)) / 10e5,
            computeLastWins(player.Username),
            player.TeamId,
            computeRecord(player.Username),
            player.PlayerNameLastFirst,
          ])
          .toSorted((lhs, rhs) => {
            if (lhs[0] > rhs[0]) { return -1; } // Points
            if (lhs[0] < rhs[0]) { return 1; }
            if (lhs[1] > rhs[1]) { return -1; } // Wins
            if (lhs[1] < rhs[1]) { return 1; }
            if (lhs[2] > rhs[2]) { return -1; } // SoS
            if (lhs[2] < rhs[2]) { return 1; }
            if ((lhs[3][0] + lhs[3][1]) / 2  > (rhs[3][0] + rhs[3][1]) / 2) {  // LastWins
              return -1;
            }
            if ((lhs[3][0] + lhs[3][1]) / 2  < (rhs[3][0] + rhs[3][1]) / 2) { return 1; }
            if (lhs[4] < rhs[4]) { return -1; } // TeamId
            if (lhs[4] > rhs[4]) { return 1; }
            return 0;
          });

        const standingsTable = document.createElement("table");
        standingsTable.setAttribute("class", "table table-striped table-hover");

        const standingsTableHeader = document.createElement("thead");
        const standingsTableHeaderRow = standingsTableHeader.insertRow();
        [
          ["Rank", 10],
          ["Player", 40],
          ["Record", 10],
          ["Points", 10],
          ["Wins", 10],
          ["SoS", 10],
          ["LastWins", 10],
        ].forEach((elem) => {
          const [text, width] = elem;
          const cell = document.createElement("th");
          cell.setAttribute("style", `width: ${width}%`);
          cell.appendChild(document.createTextNode(text))
          standingsTableHeaderRow.appendChild(cell);
        });
        standingsTable.appendChild(standingsTableHeader);

        const standingsTableBody = document.createElement("tbody");
        standings.forEach((standing, index) => {
          const rank = index + 1;
          const [points, wins, sos, lastWins, _teamId, record, name] = standing;
          const row = standingsTableBody.insertRow();
          for (text of [
            rank,
            name,
            `${record[0]}-${record[1]}-${record[2]}`,
            points,
            wins,
            `${(100 * sos).toFixed(5)}%`,
            lastWins[0] === lastWins[1] ? lastWins[0] : `[${lastWins[0]}:${lastWins[1]}]`,
          ]) {
            row.insertCell().appendChild(document.createTextNode(text));
          }
        });
        standingsTable.appendChild(standingsTableBody);

        standingsPane.appendChild(standingsTable);

        if (nextRoundPane) {
          const unpairedPlayers = players
            .filter((player) => [1, 2].includes(player.Status))
            .map((player) => [Math.random(), computePoints(player.Username), player])
            .sort((lhs, rhs) => lhs[0] - rhs[0])
            .sort((lhs, rhs) => rhs[1] - lhs[1])
            .map((t) => t[2]);
          let pairings = [];
          let table = 1;
          while (unpairedPlayers.length > 1) {
            const player1 = unpairedPlayers.shift();
            const player2 = unpairedPlayers.splice(
              unpairedPlayers.findIndex(
                (player) => !computeOpponents(player1.Username).includes(player.Username)
              ),
              1,
            )[0];
            pairings.push([table, player1, player2]);
            table += 1;
          }
          if (unpairedPlayers.length === 1) {
            pairings.unshift([null, unpairedPlayers[0], null]);
          }

          const pairingsHeader = document.createElement("h4");
          pairingsHeader.setAttribute("class", "my-2");
          pairingsHeader.appendChild(document.createTextNode("Pairings"));
          nextRoundPane.appendChild(pairingsHeader);

          const pairingsTable = document.createElement("table");
          pairingsTable.setAttribute("class", "table table-striped table-hover");

          const pairingsTableHeader = document.createElement("thead");
          const pairingsTableHeaderRow = pairingsTableHeader.insertRow();
          [["Table", 20], ["Player 1", 40], ["Player 2", 40]].forEach((elem) => {
            const [text, width] = elem;
            const cell = document.createElement("th");
            cell.setAttribute("style", `width: ${width}%`);
            cell.appendChild(document.createTextNode(text))
            pairingsTableHeaderRow.appendChild(cell);
          });
          pairingsTable.appendChild(pairingsTableHeader);

          const pairingsTableBody = document.createElement("tbody");
          pairings.forEach((pairing, index) => {
            const [table, player1, player2] = pairing;
            const row = pairingsTableBody.insertRow();
            for (text of [
              table ? `${table}` : "-",
              player1.PlayerNameLastFirst,
              player2 ? player2.PlayerNameLastFirst : "N/A (bye)",
            ]) {
              row.insertCell().appendChild(document.createTextNode(text));
            }
          });
          pairingsTable.appendChild(pairingsTableBody);

          nextRoundPane.appendChild(pairingsTable);

          const pairingsScriptHeader = document.createElement("h4");
          pairingsScriptHeader.setAttribute("class", "my-2");
          pairingsScriptHeader.appendChild(document.createTextNode("Pairings script"));
          nextRoundPane.appendChild(pairingsScriptHeader);

          const newPairings = pairings
            .map((pairing) =>
              JSON.stringify({
                TableNumber: pairing[0],
                Team1Id: pairing[1].TeamId,
                Team1Name: "",
                Team2Id: pairing[2] ? pairing[2].TeamId : null,
                Team2Name: pairing[2] ? "" : "Bye",
              })
            )
            .join(", ");
          const pairingsScript = document.createElement("pre");
          pairingsScript.setAttribute("style", "white-space: pre-wrap");
          pairingsScript.setAttribute("class", "bg-body-secondary p-3");
          pairingsScript.appendChild(document.createTextNode(
            "(function(){$.post(\"/Tournament/UpdatePairings\", {id:"
            + " $(\"#pairings-round-selector-container > .round-selector.active\")"
            + `.data("id"), newPairings: [${newPairings}], deletedPairings: []},`
            + " (response) => { Flattsware.notify.handleResponse(response, (response) =>"
            + " { updateTournamentMetrics(true), Flattsware.showSnackbarAlert("
            + "response.Message) }) }).fail(Flattsware.showFail) })()"
          ));
          nextRoundPane.appendChild(pairingsScript);
        }

        submitButton.blur();
      };
    </script>
  </body>
</html>
